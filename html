import serial
import time
import RPi.GPIO as GPIO
from flask import Flask, render_template, jsonify, send_from_directory
import threading
from datetime import datetime
import os
from luma.core.interface.serial import spi
from luma.oled.device import ssd1306
from luma.core.render import canvas
from multiprocessing import Process
import smtplib
from email.mime.multipart import MIMEMultipart
from email.mime.base import MIMEBase
from email.mime.text import MIMEText
from email import encoders

app = Flask(__name__)

GPIO.setmode(GPIO.BCM)
GPIO.setwarnings(False)
buzzer_pin = 17
led = 21
trig_pin = 26
echo_pin = 16

GPIO.setup(buzzer_pin,GPIO.OUT)
GPIO.setup(led,GPIO.OUT)
GPIO.setup(trig_pin, GPIO.OUT)
GPIO.setup(echo_pin, GPIO.IN)

BASE_DIR = os.path.dirname(os.path.abspath(__file__))
TEMPLATES_DIR = os.path.join(BASE_DIR, 'templates')
FILE_PATH = os.path.join(TEMPLATES_DIR, 'GPSfile.txt')
FILE_PATH1 = os.path.join(TEMPLATES_DIR, 'status.txt')

spi_serial = spi(device=0, port=0)
oled = ssd1306(spi_serial, rotate=2)
oled.command(0xA0)
oled.command(0xC8)

try:
    arduino = serial.Serial('/dev/ttyUSB0', 9600, timeout=1)
    arduino.flush()
    print("Serial connection established.")
except serial.SerialException as e:
    print(f"Error Opening port: {e}")
    exit()

    
def buzzer_off():
    GPIO.output(buzzer_pin, GPIO.LOW)
    
def buzzer_sensor(duration):
    GPIO.output(buzzer_pin, GPIO.HIGH)
    time.sleep(duration)
    GPIO.output(buzzer_pin, GPIO.LOW)

def write_data_to_file(file_path, data):
    with open(file_path, 'a') as file:
        file.write(data)
        file.flush()

def send_location_email(altitude, latitude, longitude, timestamp):
    sender_email = "encoderactivity@gmail.com"
    receiver_email = "pinagayaonawap22@gmail.com"
    password = "wfaf mumd yskg xwvx"
    
    msg = MIMEMultipart()
    msg['From'] = sender_email
    msg['To'] = receiver_email
    msg['Subject'] = "Tracker: Location Detected"

    body = f"Warning!\n\nLocation data detected:\nAltitude: {altitude} meters\nLatitude: {latitude} degrees\nLongitude: {longitude} degrees\nTime: {timestamp}\n\nTrack the location immediately."
    msg.attach(MIMEText(body, 'plain'))

    try:
        with smtplib.SMTP('smtp.gmail.com', 587) as server:
            server.starttls()
            server.login(sender_email, password)
            server.send_message(msg)
        print("Email sent successfully with location data!")
    except Exception as e:
        print(f"Failed to send email: {e}")

def display_text(latitude, longitude):
    try:
        with canvas(oled) as draw:
            formatted_lat = f"{latitude}"
            formatted_long = f"{longitude}"

            draw.text((10, 10), f"Latitude: {formatted_lat}", fill="red")
            draw.text((10, 30), f"Longitude: {formatted_long}", fill="red")
            
    except Exception as e:
        print(f"Error displaying text: {e}")

def distance_data():
    GPIO.output(trig_pin, True)
    time.sleep(0.00001)
    GPIO.output(trig_pin, False)

    while GPIO.input(echo_pin) == GPIO.LOW:
        pulseObject = time.time()
    while GPIO.input(echo_pin) == GPIO.HIGH:
        pulseNone = time.time()
        
    pulse_Distance = pulseNone - pulseObject
    
    distanceSensor = ((pulse_Distance * 34300) / 2)
    
    if distanceSensor <= 10:
        buzzer_sensor(3)
        GPIO.output(led, GPIO.HIGH)
    else:
        GPIO.output(led, GPIO.LOW)
        buzzer_off()

    return round(distanceSensor, 2)
     
@app.route('/')
def index():
    return render_template('index1.html')

@app.route('/Gps_data')
def Gps_data():
    counter = 0
    distance = distance_data()
    current_time = datetime.now()

    latitude = None
    longitude = None
    altitude = None
    
    print(f"Distance: {distance}")
    if arduino.in_waiting > 0: 
        data = arduino.readline().decode('utf-8').strip()
        try:
            latitude, longitude, altitude = map(float, data.split(","))
            print(f"latitude: {latitude} | longitude: {longitude} | altitude: {altitude}")
        except ValueError:
            print(f"Error parsing data: {data}")

    if distance < 10:
        write_data_to_file(FILE_PATH, f'{distance},{latitude},{longitude},{altitude},{current_time}\n')
        counter += 1
        try:
            send_location_email(altitude, latitude, longitude)
            time.sleep(1)
        except Exception as e:
            print(f"Failed to send email: {e}")
        time.sleep(0.5)
        
    display_text(latitude, longitude)
    
    if counter >= 20:
        counter = 0
        print("Resetting file")
        with open(FILE_PATH, 'w') as file:
            pass 

    return jsonify(distanceact6=distance, latitude=latitude, longitude=longitude, altitude=altitude, current_time=current_time)

def run_flask():
    app.run(host='0.0.0.0', port=5086, debug=True)

@app.route('/GPSfile.txt')
def get_file_motion():
    return send_from_directory(TEMPLATES_DIR, 'GPSfile.txt')

def run_gps_oled():
    with app.app_context():
        while True:
            Gps_data()
            time.sleep(1)

current_status = "inactive"
@app.route('/toggle_status', methods=['POST'])
def toggle_status():
    global current_status
 
    current_status = "active" if current_status == "inactive" else "inactive"

    with open(FILE_PATH1, 'w') as file:
        file.write(current_status)
    return jsonify(status=current_status)
      
if __name__ == '__main__':
    gps_oled_thread = threading.Thread(target=run_gps_oled)
    gps_oled_thread.start()

    run_flask()

