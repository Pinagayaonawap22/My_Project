import RPi.GPIO as GPIO
import mysql.connector
import time
import os
import serial
from luma.core.interface.serial import spi
from luma.oled.device import ssd1306
from luma.core.render import canvas
from datetime import datetime 
from multiprocessing import Process
from flask import Flask, render_template, request
from flask import send_from_directory, send_file, Response

app = Flask(__name__)

spi_serial = spi(device=0, port=0)
oled = ssd1306(spi_serial, rotate=2)
oled.command(0xA0)
oled.command(0xC8)

def Db_connection():
    try:
        connection = mysql.connector.connect(
            host='localhost',
            user='Embedded_act',
            password='bet1234',
            database='mydatabase'
        )
        print("Database connection successful")
        return connection
    except mysql.connector.Error as err:
        print(f"Database connection error: {err}")
        return None

def insert_data_into_db(smoke_value, vibration_status, smokebuzzer, vibrationbuzzer, timestamp):
    connection = Db_connection()
    if connection:
        try:
            cursor = connection.cursor()
            sql_query = """
                INSERT INTO sensor_data (smoke_value, vibration_status, smoke_buzzer, vibration_buzzer, time)
                VALUES (%s, %s, %s, %s, %s)
            """
            cursor.execute(sql_query, (smoke_value, vibration_status, smokebuzzer, vibrationbuzzer, timestamp))
            connection.commit()
            print("Data inserted successfully")
        except mysql.connector.Error as err:
            print(f"Error inserting data: {err}")
        finally:
            cursor.close()
            connection.close()

def reset_table():
    connection = Db_connection()
    if connection:
        try:
            cursor = connection.cursor()
            delete_query = "DELETE FROM sensor_data"
            cursor.execute(delete_query)
            connection.commit()
            print("Table reset successfully")
        except mysql.connector.Error as err:
            print(f"Error resetting table: {err}")
        finally:
            cursor.close()
            connection.close()

GPIO.setmode(GPIO.BCM)
GPIO.setwarnings(False)

Vibration_pin = 16
buzzer_pin = 27
status_button = 23
sensorstatus = 0  
smokestatus = 0   
Vibrationstatus = 0  

GPIO.setup(Vibration_pin, GPIO.IN)
GPIO.setup(buzzer_pin, GPIO.OUT)
GPIO.setup(status_button, GPIO.IN, pull_up_down=GPIO.PUD_UP) 

last_button_state = GPIO.input(status_button)

def buzzer_on():
    GPIO.output(buzzer_pin, GPIO.HIGH)

def buzzer_off():
    GPIO.output(buzzer_pin, GPIO.LOW)

def buzzer_time(duration):
    GPIO.output(buzzer_pin, GPIO.HIGH)
    time.sleep(duration)
    GPIO.output(buzzer_pin, GPIO.LOW)

try:
    arduino = serial.Serial('/dev/ttyACM0', 9600, timeout=1)
    arduino.flush()
except serial.SerialException as e:
    print(f"Error Opening port: {e}")
    exit()

def SmokeSensor():
    global smokestatus
    if smokestatus == 1:
        if arduino.in_waiting > 0:
            line = arduino.readline().decode('utf-8').rstrip()
            if int(line) > 85:
                buzzer_time(3)
            else:
                buzzer_off()
            return line 
        else:
            return "No data from Arduino" 
    else:
        return "Smoke sensor is off"

def VibrationSensor():
    global Vibrationstatus
    if Vibrationstatus == 1:
        if GPIO.input(Vibration_pin):
            buzzer_time(2)  
            return "1" 
        else:
            buzzer_off()
            return "0" 
    else:
        return "Vibration sensor is off"

def display_text(smoke_value, vibration_status):
    try:
        with canvas(oled) as draw:
            formatted_smoke = f"{smoke_value}" 
            formatted_vibration = f"{vibration_status}"

            draw.text((10, 10), f"Smoke: {formatted_smoke} ppm", fill="blue")
            draw.text((10, 30), f"Vibration: {formatted_vibration} g", fill="blue")

    except Exception as e:
        print(f"Error displaying text: {e}")

data_count = 0

def disasteract():
    global data_count
    try:
        while True:
            current_button_state = GPIO.input(status_button)

            if last_button_state == GPIO.HIGH and current_button_state == GPIO.LOW:
                sensorstatus = 1 if sensorstatus == 0 else 0  
                smokestatus = sensorstatus  
                Vibrationstatus = sensorstatus 
                time.sleep(0.2) 

            last_button_state = current_button_state 
            
            smoke_value = SmokeSensor()  
            vibration_status = VibrationSensor() 
            display_text(smoke_value, vibration_status)

            smokebuzzer = "Active" if int(smoke_value) > 85 else "Inactive"
            vibrationbuzzer = "Active" if vibration_status == "1" else "Inactive"

            print(f"{smoke_value}") 
            print(f"{vibration_status}") 

            current_time = datetime.now()

            insert_data_into_db(smoke_value, vibration_status, smokebuzzer, vibrationbuzzer, current_time)

            data_count += 1

            if data_count >= 100:
                reset_table()
                data_count = 0 

            time.sleep(1) 

    except KeyboardInterrupt:
        print("Program stopped by User")

    finally:
        GPIO.cleanup()

@app.route('/')
def index():
    return render_template('index1.html')

@app.route('/data')
def show_data():
    connection = Db_connection()
    if connection:
        try:
            cursor = connection.cursor(dictionary=True)
            cursor.execute("SELECT * FROM sensor_data")
            data = cursor.fetchall()
            return render_template('data_display.html', data=data)
        except mysql.connector.Error as err:
            print(f"Error fetching data: {err}")
            return "Error fetching data"
        finally:
            cursor.close()
            connection.close()
    return "Database connection error"

def run_flask():
    app.run(host='0.0.0.0', port=5066, debug=True)

if __name__ == "__main__":
    disaster = Process(target=disasteract)
    disaster.start()
    run_flask()
